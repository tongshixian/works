**一、什么是Redis Sentinel，为什么我们需要使用Redis Sentinel**

谈Redis Sentinel之前，再回顾一下Redis的主从复制。在主从复制模式下我们可以将主节点的改变的数据同步给从节点，这样从节点可以用作主节点数据的一个备份，在主节点故障宕机的情况下，从节点可以当作备用机顶上来。并且在一主多从的拓扑结构中，从节点能拓展主节点的读的能力，读写分离，在并发量很大的时候从节点一定程度上能帮主节点分担一部分压力。主从复制虽然带来了很多好处，但也存在这么一些问题：

- 倘若主节点出现了故障，我们就得人工将一个从节点晋升为一个主节点，然后修改其他的从节点的主从复制，修改应用的主节点的地址，并且人工控制不能保证即使行
- 主节点写入与存储的能力受到单个机器的限制

Redis Sentinel主要解决的就是第一点，实现Redis高可用的一个方案。在没有Redis Sentinel之前我们主节点故障通常都是走的以下的流程

- 主节点发生了故障，导致客户端连接失败并且从节点复制失败
- 若主节点无法正常启动的情况下，就会选择一个从节点进行slave of no one 的操作，让它重新晋升为主节点
- 更新软件应用的主节点的信息
- 使用slave of {newMaster} ，与新的主节点建立复制关系。
- 原来的主节点恢复后与新的主节点建立复制关系，降为从节点

**哨兵实现原理**

Redis哨兵的三个定时任务，Redis哨兵判定一个Redis节点故障不可达主要就是通过三个定时监控任务来完成的：

- 每隔10秒每个哨兵节点会向主节点和从节点发送"info replication" 命令来获取最新的拓扑结构 
- 每隔2秒每个哨兵节点会向Redis节点的_sentinel_:hello频道发送自己对主节点是否故障的判断以及自身的节点信息，并且其他的哨兵节点也会订阅这个频道来了解其他哨兵节点的信息以及对主节点的判断
- 每隔1秒每个哨兵会向主节点、从节点、其他的哨兵节点发送一个 “ping” 命令来做心跳检测

**主观下线与客观下线**

- 哨兵节点由定时任务3，每隔1秒会向主节点、从节点、其他的哨兵节点发送ping命令做心跳检测，如果这些被监控的节点在配置的down-after-milliseconds时间内没有pong回复，哨兵就会主观的判断这个节点故障不可达了，也就是日志里面记录的sdown。
- 当哨兵判断主观下线的节点时主节点的时候，就会通过sentinel is-master-down-by-addr 命令向其他的哨兵节点询问它们对主节点进行的判断，如果其他的哨兵也认为主节点主观线下了，则当认为主观下线的票数超过了<quorum>数时，那么这个主节点确实就可能是故障不可达了，这时就由原来的主观下线sdown变为了客观下线odown。

**故障转移哨兵leader选举**

如果主节点被判定为客观下线之后，就要选取一个哨兵节点来完成后面的故障转移工作，选举出一个leader的流程如下:

- 每一个哨兵节点都可以成为leader完成故障转移工作，这时它会向其他的哨兵发送 sentinel is-master-down-by-addr,请求当leader
- 收到请求的哨兵节点如果没有把自己那唯一一张票数投出去，则投给请求者同意请求者当选leader，否则拒绝
- 哨兵如果发现自己得到的票数大于等于max(quorums,哨兵数/2 +1 )，则它就成为了leader
- 如果这一轮没有选出leader，那么就开始下一轮的选举

**故障转移**

故障转移也就是在从节点中选出一个节点来当新的主节点，选择的流程如下：

- 过滤掉主观下线的节点 
- 选择slave-priority最高的节点，如果由则返回没有就继续选择
- 选择出复制偏移量最大的系节点，因为复制便宜量越大则数据复制的越完整，如果由就返回了，没有就继续
- 选择run_id最小的节点