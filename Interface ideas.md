#PHP 处理接口保证数据安全性

原地址：http://blog.csdn.net/lhbeggar/article/details/46377653

php做APP接口时，如何保证接口的安全性？

1、当用户登录APP时，使用https协议调用后台相关接口，服务器端根据用户名和密码时生成一个access_key，并将access_key保存在session中，将生成的access_key和session_id返回给APP端。

2、APP端将接收到的access_key和session_id保存起来

3、当APP端调用接口传输数据时，将所传数据和access_key使用加密算法生成签名signature，并将signature和session_id一起发送给服务器端。

4、服务器端接收到数据时，使用session_id从session中获取对应的access_key，将access_key和接收到的数据使用同一加密算法生成对应signature，如果生成的签名和接收到的signature相同时，则表明数据合法

#如何限制接口调用者对接口的调用频率？

##在缓存中以调用者唯一标识记录调用次数，缓存过期时间为你要限制的时间。比如你需要控制1分钟1000次的调用限制，缓存过期时间就是1分钟，调用次数判断不大于1000即可。

问题:对某个对外暴露的接口加一个限制:调用者一分钟之内调用次数不能超过100次,如果超过100次就直接返回给调用者失败的信息。
给调用者一个SECRET，每次调用者需要调用接口的时候,都需要把这个SECRET带过来(为了安全需要对key进行一系列加密的措施)

一个SECRET就代表一个调用者,把相应的SECRET的调用次数放入缓存中(必须确保次数增加的原子性)，并且把SECRET当做缓存的SECRET(这里如果区分方法的话,可以把方法和KEY做一次加密）。

这里主要的难点就是,如何判断调用者1分钟之内调用次数是否超过100？也就是很难确实这个1分钟的开始时间。

我现在的想法是:分别把当前秒调用的次数存入缓存。比如说,当前调用者调用次数为3,那么我就往缓存中加入KEY=SECRET_1,VALUE=3;然后调用者在第二秒调用的次数为4，那么就往缓存中加入KEY=SECRET_2,VALUE=3;如此循环,当循环到61秒的时候替换KEY=SECRET_1中得VAALUE,每次调用的时候计算SECRET_1~SECRET_60的值来判断调用次数,是否超过100次。(这里具体一秒钟调用几次,需要通过时间戳来算出是第几秒。这里以60秒为时间周期,并且以秒为一个时间单位,当然如果要求不是很准确的话,时间单位可以调大一点)

#php接口安全设计浅谈

https://www.cnblogs.com/zouke1220/p/9394356.html


----------

接口的安全性主要围绕Token、Timestamp和Sign三个机制展开设计，保证接口的数据不会被篡改和重复调用。

**Token授权机制：（Token是客户端访问服务端的凭证）**
用户使用用户名密码登录后服务端给客户端返回一个Token（通常是UUID），并将Token-UserId以键值对的形式存放在缓存服务器中。服务端接收到请求后进行Token验证，如果Token不存在，说明请求无效。

**时间戳超时机制：（签名机制保证了数据不会被篡改）**
用户每次请求都带上当前时间的时间戳timestamp，服务端接收到timestamp后跟当前时间进行比对，如果时间大于一定时间（比如5分钟），则认为该请求失效。**时间戳超时机制是防御DOS攻击的有效手段**。
